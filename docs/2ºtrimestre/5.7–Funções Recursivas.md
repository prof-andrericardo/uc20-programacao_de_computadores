# ğŸ” CapÃ­tulo 5.7 â€“ FunÃ§Ãµes Recursivas

> âœ¨ *â€œUma funÃ§Ã£o que chama a si mesma? Parece confuso no inÃ­cio, mas a recursÃ£o Ã© uma ferramenta poderosa para resolver problemas que se repetem em estrutura.â€*

------

## ğŸ“˜ 5.7.1 O que Ã© recursÃ£o?

### ğŸ§  Conceito

Uma **funÃ§Ã£o recursiva** Ã© uma funÃ§Ã£o que **chama a si mesma** dentro de seu prÃ³prio corpo, atÃ© atingir uma **condiÃ§Ã£o de parada**.

> ğŸ” A ideia Ã© **dividir o problema em versÃµes menores de si mesmo**, atÃ© que se chegue a um caso tÃ£o simples que ele possa ser resolvido diretamente.

------

## ğŸ”„ 5.7.2 Estrutura de uma funÃ§Ã£o recursiva

```python
def funcao():
    if condiÃ§Ã£o_de_parada:
        return resultado_final
    else:
        return chamada_recursiva(...)
```

| Parte              | ExplicaÃ§Ã£o                                            |
| ------------------ | ----------------------------------------------------- |
| CondiÃ§Ã£o de parada | Garante que a funÃ§Ã£o pare em algum momento            |
| Chamada recursiva  | Reduz o problema e reinicia a funÃ§Ã£o com nova entrada |

------

## ğŸ§ª 5.7.3 Exemplo clÃ¡ssico: Fatorial

### ğŸ§  O que Ã© o fatorial de um nÃºmero?

- `5!` (5 fatorial) significa: `5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120`
- Em forma recursiva:
  - `fatorial(5) = 5 Ã— fatorial(4)`
  - `fatorial(4) = 4 Ã— fatorial(3)`
  - ...
  - `fatorial(1) = 1` â†’ **caso base**

------

### âœ… ImplementaÃ§Ã£o detalhada:

```python
def fatorial(n):
    if n == 1:
        return 1                # Caso base: fatorial(1) = 1
    else:
        return n * fatorial(n - 1)  # Chamada recursiva

print(fatorial(5))  # SaÃ­da: 120
```

### ğŸ” ExplicaÃ§Ã£o passo a passo:

1. `fatorial(5)` â†’ retorna `5 * fatorial(4)`
2. `fatorial(4)` â†’ retorna `4 * fatorial(3)`
3. ...
4. `fatorial(1)` â†’ retorna `1` â†’ **fim da recursÃ£o**
5. A pilha de chamadas retorna os valores multiplicados em ordem reversa.

------

## ğŸ§  5.7.4 Outro exemplo: contagem regressiva

```python
def contagem(n):
    if n == 0:
        print("FIM!")
    else:
        print(n)
        contagem(n - 1)

contagem(5)
```

### ğŸ” O que acontece:

- A funÃ§Ã£o imprime `5`, depois chama `contagem(4)`
- E assim por diante, atÃ© chegar a `contagem(0)`, que imprime `"FIM!"`

------

## ğŸ§  5.7.5 RecursÃ£o vs laÃ§o

### ğŸ”„ Usando `for` para fatorial:

```python
def fatorial_iterativo(n):
    resultado = 1
    for i in range(1, n + 1):
        resultado *= i
    return resultado
```

ğŸ“Œ RecursÃ£o e laÃ§os **podem resolver os mesmos problemas**, mas recursÃ£o Ã© mais elegante para:

- Ãrvores
- Fractais
- Problemas que exigem â€œvoltar no tempoâ€ (ex: backtracking)

------

## âš ï¸ 5.7.6 Cuidados com recursÃ£o

| Risco                   | Como evitar                                   |
| ----------------------- | --------------------------------------------- |
| âŒ RecursÃ£o infinita     | Sempre definir um **caso base**               |
| â— Erro `RecursionError` | Python limita a profundidade (~1000 chamadas) |
| ğŸ’¡ Excesso de chamadas   | Prefira laÃ§os em tarefas simples ou longas    |

------

## âœ… Boas prÃ¡ticas com recursÃ£o

| Boa prÃ¡tica                              | Justificativa                             |
| ---------------------------------------- | ----------------------------------------- |
| Sempre definir **caso base claro**       | Garante que a recursÃ£o vai parar          |
| Certifique-se de **diminuir o problema** | Evita chamadas infinitas                  |
| Use apenas quando realmente necessÃ¡rio   | Evita uso excessivo de memÃ³ria e confusÃ£o |

------

## ğŸ§  Desafio guiado com explicaÃ§Ãµes

> Crie uma funÃ§Ã£o recursiva que calcule a soma dos nÃºmeros de 1 atÃ© `n`.

```python
def somatorio(n):
    if n == 1:
        return 1
    else:
        return n + somatorio(n - 1)

print(somatorio(4))  # SaÃ­da: 10 (4 + 3 + 2 + 1)
```

------

## ğŸ“˜ ExercÃ­cios Propostos

1. ğŸ” Crie uma funÃ§Ã£o recursiva que imprima os nÃºmeros de `n` atÃ© 1 (contagem decrescente).
2. ğŸ§® Crie uma funÃ§Ã£o `potencia(base, expoente)` que calcula `base ** expoente` recursivamente.
3. ğŸ“¦ Crie uma funÃ§Ã£o `soma_lista(lista)` que soma todos os elementos de uma lista usando recursÃ£o.
4. ğŸ§© Crie uma funÃ§Ã£o `palindromo(texto)` que verifica se um texto Ã© igual ao seu inverso usando recursÃ£o.
5. ğŸ§  Desafio:
   - Crie uma funÃ§Ã£o recursiva `decimal_para_binario(n)`
   - Converta um nÃºmero decimal para uma string com sua **representaÃ§Ã£o binÃ¡ria**
   - Exemplo: `decimal_para_binario(10)` â†’ `"1010"`

------

