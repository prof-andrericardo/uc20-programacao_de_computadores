# üìñ Cap√≠tulo 2 - Estruturas de Controle em Python

## ‚ú® Introdu√ß√£o

"A verdadeira efici√™ncia est√° em escolher o caminho certo no momento certo. Assim como na vida, um programa precisa tomar decis√µes de forma organizada e precisa. O `match/case` nos permite estruturar essas escolhas de maneira clara e direta."

Com o lan√ßamento do **Python 3.10**, foi introduzido o comando `match/case`, uma alternativa mais elegante e leg√≠vel para substituir m√∫ltiplos `if/elif/else` quando trabalhamos com **compara√ß√µes diretas de valores**.

Neste cap√≠tulo, exploraremos detalhadamente:

- **A estrutura b√°sica do `match/case`**
- **Compara√ß√£o entre `if/elif/else` e `match/case`**
- **Casos pr√°ticos de uso**
- **Combina√ß√µes de padr√µes no `match/case`**
- **Uso de `_` como caso padr√£o**
- **Padr√µes avan√ßados com listas e dicion√°rios**

Nosso objetivo √© proporcionar um entendimento profundo desse novo recurso, facilitando sua aplica√ß√£o em projetos reais.

------

## 2Ô∏è‚É£ O Comando `match/case`

O `match/case` √© uma **estrutura de controle de fluxo** que permite verificar **diferentes padr√µes de valores** de uma vari√°vel, funcionando de maneira semelhante ao `switch/case` de outras linguagens como C e JavaScript.

### 2.1 Estrutura e Sintaxe do `match/case`

A sintaxe do `match/case` segue o seguinte formato:

```python
match vari√°vel:
    case valor1:
        # C√≥digo executado se vari√°vel == valor1
    case valor2:
        # C√≥digo executado se vari√°vel == valor2
    case _:
        # C√≥digo executado se nenhum dos casos anteriores for verdadeiro
```

### üîπ Exemplo 1: Criando um Menu Interativo

```python
opcao = int(input("Escolha uma op√ß√£o (1, 2 ou 3): "))

match opcao:
    case 1:
        print("Voc√™ escolheu a op√ß√£o 1: Cadastro de Usu√°rio.")
    case 2:
        print("Voc√™ escolheu a op√ß√£o 2: Consulta de Dados.")
    case 3:
        print("Voc√™ escolheu a op√ß√£o 3: Sair do Sistema.")
    case _:
        print("Op√ß√£o inv√°lida! Escolha 1, 2 ou 3.")
```

**Explica√ß√£o:**

1. O programa recebe um n√∫mero digitado pelo usu√°rio.
2. O `match` verifica qual dos `case` corresponde ao valor inserido.
3. Se o valor digitado n√£o corresponder a nenhum dos `case`, o `case _` ser√° executado como op√ß√£o padr√£o.

------

### 2.2 Compara√ß√£o entre `if/elif/else` e `match/case`

Antes da chegada do `match/case`, as decis√µes com m√∫ltiplos valores eram feitas com `if/elif/else`:

```python
opcao = int(input("Escolha uma op√ß√£o (1, 2 ou 3): "))

if opcao == 1:
    print("Cadastro de Usu√°rio.")
elif opcao == 2:
    print("Consulta de Dados.")
elif opcao == 3:
    print("Sair do Sistema.")
else:
    print("Op√ß√£o inv√°lida!")
```

### üÜö Compara√ß√£o Direta

| **Crit√©rio** | **if/elif/else**   | **match/case**        |
| ------------ | ------------------ | --------------------- |
| Legibilidade | M√©dia              | Alta                  |
| Desempenho   | Igual              | Igual                 |
| Estrutura    | Encadeada (`elif`) | Organizada por blocos |
| Uso Ideal    | Condi√ß√µes variadas | Compara√ß√£o direta     |

**Conclus√£o:** O `match/case` √© **mais organizado e leg√≠vel** para **compara√ß√µes diretas**.

------

### 2.3 Uso do `_` como Caso Padr√£o

O `_` (underscore) funciona como um **"caso gen√©rico"**, ou seja, ser√° executado caso nenhuma outra condi√ß√£o seja atendida.

### üîπ Exemplo 2: Verificando Dias da Semana

```python
dia = input("Digite um dia da semana: ").lower()

match dia:
    case "segunda":
        print("In√≠cio da semana! Vamos trabalhar!")
    case "sexta":
        print("Sexta-feira! O final de semana est√° chegando!")
    case "s√°bado" | "domingo":
        print("Fim de semana! Hora de descansar!")
    case _:
        print("Dia inv√°lido.")
```

**Explica√ß√£o:**

- Se o usu√°rio digitar "s√°bado" ou "domingo", ambos cair√£o no mesmo `case` devido ao operador `|` (OU).
- O `_` trata qualquer entrada inv√°lida, garantindo uma resposta padr√£o.

------

### 2.4 Padr√µes Avan√ßados no `match/case`

Podemos utilizar `match/case` para trabalhar com **listas e dicion√°rios**, extraindo informa√ß√µes espec√≠ficas.

### üîπ Exemplo 3: Analisando Listas

```python
def verificar_lista(lista):
    match lista:
        case []:
            print("A lista est√° vazia.")
        case [primeiro, *resto]:
            print(f"O primeiro elemento √© {primeiro} e h√° mais {len(resto)} elementos na lista.")
```

**Explica√ß√£o:**

- Se a lista for vazia, o primeiro `case` ser√° acionado.
- Caso contr√°rio, o `case [primeiro, *resto]` extrai o **primeiro elemento** e o restante dos elementos.

### üîπ Exemplo 4: Filtrando Dados de um Dicion√°rio

```python
dados = {"nome": "Carlos", "idade": 30}

match dados:
    case {"nome": nome, "idade": idade}:
        print(f"Nome: {nome}, Idade: {idade} anos.")
    case _:
        print("Formato inv√°lido de dados.")
```

**Explica√ß√£o:**

- Se o dicion√°rio contiver `"nome"` e `"idade"`, os valores s√£o extra√≠dos e exibidos.
- Caso contr√°rio, `case _` lida com formatos inv√°lidos.

------

## üìå Conclus√£o

Com o `match/case`, o Python agora possui uma **forma mais clara e organizada** de lidar com m√∫ltiplas compara√ß√µes diretas. Ao longo deste cap√≠tulo, aprendemos:

‚úîÔ∏è A estrutura e funcionamento do `match/case`. ‚úîÔ∏è Compara√ß√£o entre `if/elif/else` e `match/case`. ‚úîÔ∏è O uso do `_` como op√ß√£o padr√£o. ‚úîÔ∏è Aplica√ß√µes avan√ßadas com listas e dicion√°rios.

üöÄ **Agora que dominamos o `match/case`, podemos aplic√°-lo em projetos para tornar nossos c√≥digos mais eficientes e leg√≠veis!**